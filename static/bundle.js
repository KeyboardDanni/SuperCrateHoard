(()=>{"use strict";class t{constructor(t){this.imageElement=new Image,this.imageElement.loading="eager",this.imageElement.src=t}image(){return this.imageElement}waitForLoad(){return t=this,e=void 0,s=function*(){yield this.imageElement.decode()},new((i=void 0)||(i=Promise))((function(n,a){function r(t){try{c(s.next(t))}catch(t){a(t)}}function o(t){try{c(s.throw(t))}catch(t){a(t)}}function c(t){var e;t.done?n(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,o)}c((s=s.apply(t,e||[])).next())}));var t,e,i,s}}class e{constructor(i){if(!e.dataCache[i]){const s=new t(i);e.dataCache[i]=s}this.pictureData=e.dataCache[i]}sharedData(){return this.pictureData}static waitForLoad(){for(const t of Object.values(e.dataCache))t.waitForLoad()}}e.dataCache={};class i{constructor(t){if(this.mainCanvas=document.getElementById(t),!this.mainCanvas||!this.mainCanvas.getContext)throw new Error("Missing canvas");const e=this.mainCanvas.getContext("2d");if(!e)throw new Error("Could not create canvas context");this.drawingContext=e,document.addEventListener("keydown",(t=>{t.altKey&&"Enter"==t.code&&!t.repeat&&this.toggleFullscreen()}))}drawBackgroundColor(t,e,i,s=1){this.drawingContext.fillStyle=`rgb(${t}, ${e}, ${i}, ${s})`,this.drawingContext.fillRect(-1,-1,this.mainCanvas.width+2,this.mainCanvas.height+2)}drawPicture(t,e,i){this.drawingContext.drawImage(t.sharedData().image(),e,i)}drawSprite(t,e,i,s){this.drawingContext.drawImage(t.sharedData().image(),e.x,e.y,e.w,e.h,Math.round(i),Math.round(s),e.w,e.h)}toggleFullscreen(){document.fullscreenElement?document.exitFullscreen():this.mainCanvas.requestFullscreen({navigationUI:"hide"})}canvas(){return this.mainCanvas}context(){return this.drawingContext}}class s{constructor(){this.bindings=[],this.timeHeld=0}}class n{constructor(){this.heldKeys={},this.actions={},document.addEventListener("keydown",(t=>this.keyDownHandler(t))),document.addEventListener("keyup",(t=>this.keyUpHandler(t))),document.addEventListener("contextmenu",(t=>{t.preventDefault(),t.stopPropagation()}))}keyDownHandler(t){this.heldKeys[t.code]=!0}keyUpHandler(t){this.heldKeys[t.code]=!1}newFrame(){t:for(const t of Object.values(this.actions)){for(const e of t.bindings)if(!0===this.heldKeys[e]){t.timeHeld++;continue t}t.timeHeld=0}}addAction(t,e=[]){if(this.actions[t])throw new Error(`Action "${t}" already exists`);this.actions[t]=new s,this.bindAction(t,e)}bindAction(t,e){const i=this.actions[t];if(!i)throw new Error(`Action "${t}" doesn't exist`);for(const t of e)t in i.bindings||i.bindings.push(t)}clearActionBindings(t){const e=this.actions[t];if(!e)throw new Error(`Action "${t}" doesn't exist`);e.bindings=[]}timeHeld(t){const e=this.actions[t];return e?e.timeHeld:0}held(t){return this.timeHeld(t)>0}justPressed(t){return 1===this.timeHeld(t)}autoRepeat(t,e,i){const s=this.timeHeld(t);return 1===s||s>=e&&(s-e)%i==0}}class a{constructor(){this.tickLogic=[],this.drawLogic=[]}tick(t){for(const e of this.tickLogic)e.tick(t,this)}draw(t,e){for(const i of this.drawLogic)i.draw(t,this,e)}addTickLogic(t){this.tickLogic.push(t)}addDrawLogic(t){this.drawLogic.push(t)}}const r=1e3/60;class o{constructor(){this.timestamp=0,this.goodSamples=0,this.timings=[],this.lastGoodAverage=r}updateTimings(){const t=performance.now();if(this.timestamp<=0)return void(this.timestamp=t);const e=t-this.timestamp;this.timestamp=t,e>20.1||(this.timings.length>=60&&this.timings.shift(),this.timings.length>0&&(Math.abs(this.timings[this.timings.length-1]-e)>6||Math.abs(this.averageRateRaw()-e)>6?this.goodSamples=0:this.goodSamples+=1),this.timings.push(e))}averageRateRaw(){let t=0;for(const e of this.timings)t+=e;return t/this.timings.length}averageRate(){return this.hasEnoughSamples()&&(this.lastGoodAverage=this.averageRateRaw()),this.lastGoodAverage}shouldLerp(){const t=this.averageRate();return Math.abs(t-r)>1}hasEnoughSamples(){return this.goodSamples>60}reset(){this.timestamp=0,this.goodSamples=0,this.timings=[]}}class c{constructor(t){this.currentScene=new a,this.pendingSceneFunc=null,this.vsyncRate=new o,this.lastTick=performance.now(),this.tickQueue=0,this.framesSinceTickLag=0,this.doDraw=!1,this.doLerp=!1,this.running=!1,this.gameInput=new n,this.gameRenderer=new i(t)}run(){if(this.running)throw new Error("run() already called");this.running=!0,this.lastTick=performance.now(),this.tickQueue=0,requestAnimationFrame(this.timerUpdate.bind(this))}scene(){return this.currentScene}setScene(t){this.pendingSceneFunc=t}input(){return this.gameInput}renderer(){return this.gameRenderer}timerUpdate(){this.vsyncRate.updateTimings(),null!==this.pendingSceneFunc&&(this.currentScene=this.pendingSceneFunc(),this.pendingSceneFunc=null),this.updateTicks(),this.updateDraw(),requestAnimationFrame(this.timerUpdate.bind(this))}updateTicks(){const t=performance.now();for(this.tickQueue+=t-this.lastTick,this.lastTick=t;this.tickQueue>=r;){this.gameInput.newFrame(),this.currentScene.tick(this),this.framesSinceTickLag++,this.doDraw=!0,this.tickQueue-=r;const e=performance.now();if(e-t>33.333333333333336){this.tickQueue=0,this.lastTick=e,this.framesSinceTickLag=0;break}}this.doLerp=this.vsyncRate.shouldLerp()&&this.framesSinceTickLag>=4}updateDraw(){if(!this.doDraw)return;let t;this.doLerp?t=this.tickQueue/r:(t=1,this.doDraw=!1),this.gameRenderer.drawBackgroundColor(0,0,0),this.currentScene.draw(this,t)}}const h={x:0,y:96,w:32,h:32};class d{constructor(t){this.canvas=null,this.scroll=0,this.scrollSpeed=t,this.image=new e("res/GameAtlas.png")}createCanvas(){if(this.canvas)return;const t=[];for(let e=0;e<1024;++e)t.push(Math.random()<.3);const e=Object.assign({},h),i=new OffscreenCanvas(32*e.w,32*e.h),s=i.getContext("2d");if(!s)throw new Error("Offscreen canvas context failed");const n=Math.ceil(i.width/e.w)+1,a=Math.ceil(i.height/e.h)+1;for(let i=0;i<a;++i)for(let a=0;a<n;++a){e.x=(a+i)%2?32:0;const[n,r]=[a%32,i%32];t[n+32*r]&&(e.x+=64),s.drawImage(this.image.sharedData().image(),e.x,e.y,e.w,e.h,a*e.w,i*e.h,e.w,e.h)}this.canvas=i}tick(t,e){this.scroll+=this.scrollSpeed}draw(t,e,i){if(this.createCanvas(),!this.canvas)return;const s=t.renderer(),[n,a]=[s.canvas().width,s.canvas().height],r=Math.ceil(n/this.canvas.width)+1,o=Math.ceil(a/this.canvas.height)+1,c=s.context();var h,d,u;const l=(h=this.scroll-this.scrollSpeed,d=this.scroll,((u=i)<=0?h:u>=1?d:h+u*(d-h))%this.canvas.height);for(let t=0;t<o;++t)for(let e=0;e<r;++e)c.drawImage(this.canvas,Math.floor(e*this.canvas.width-l),Math.floor(t*this.canvas.height-l))}}window.onload=function(){const t=new c("game_surface"),i=t.input();i.addAction("left",["ArrowLeft","KeyA"]),i.addAction("right",["ArrowRight","KeyD"]),i.addAction("up",["ArrowUp","KeyW"]),i.addAction("down",["ArrowDown","KeyS"]),t.setScene((()=>function(){const t=new a,i=new d(.25);return t.addTickLogic(i),t.addDrawLogic(i),e.waitForLoad(),t}())),t.run()}})();