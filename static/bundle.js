(()=>{"use strict";class t{constructor(){this.tickLogic=[],this.drawLogic=[]}tick(t){for(const i of this.tickLogic)i.tick(t,this)}draw(t,i){for(const s of this.drawLogic)s.draw(t,this,i)}addTickLogic(t){this.tickLogic.push(t)}addDrawLogic(t){this.drawLogic.push(t)}}const i=1e3/60;class s{constructor(){this.timestamp=0,this.goodSamples=0,this.timings=[],this.lastGoodAverage=i}updateTimings(){const t=performance.now();if(this.timestamp<=0)return void(this.timestamp=t);const i=t-this.timestamp;this.timestamp=t,i>20.1||(this.timings.length>=60&&this.timings.shift(),this.timings.length>0&&(Math.abs(this.timings[this.timings.length-1]-i)>6||Math.abs(this.averageRateRaw()-i)>6?this.goodSamples=0:this.goodSamples+=1),this.timings.push(i))}averageRateRaw(){let t=0;for(const i of this.timings)t+=i;return t/this.timings.length}averageRate(){return this.hasEnoughSamples()&&(this.lastGoodAverage=this.averageRateRaw()),this.lastGoodAverage}shouldLerp(){const t=this.averageRate();return Math.abs(t-i)>1}hasEnoughSamples(){return this.goodSamples>60}reset(){this.timestamp=0,this.goodSamples=0,this.timings=[]}}class e{constructor(){if(this.currentScene=new t,this.pendingSceneFunc=null,this.vsyncRate=new s,this.lastTick=performance.now(),this.tickQueue=0,this.framesSinceTickLag=0,this.doDraw=!1,this.doLerp=!1,this.running=!1,this.canvas=document.getElementById("game_surface"),!this.canvas||!this.canvas.getContext)throw new Error("Missing canvas");if(this.context=this.canvas.getContext("2d"),!this.context)throw new Error("Could not create canvas context")}run(){if(this.running)throw new Error("run() already called");this.running=!0,this.lastTick=performance.now(),this.tickQueue=0,requestAnimationFrame(this.timerUpdate.bind(this))}scene(){return this.scene}setScene(t){this.pendingSceneFunc=t}drawContextRaw(){return this.context}timerUpdate(){this.vsyncRate.updateTimings(),null!==this.pendingSceneFunc&&(this.currentScene=this.pendingSceneFunc(),this.pendingSceneFunc=null),this.updateTicks(),this.updateDraw(),requestAnimationFrame(this.timerUpdate.bind(this))}updateTicks(){const t=performance.now();for(this.tickQueue+=t-this.lastTick,this.lastTick=t;this.tickQueue>=i;){this.currentScene.tick(this),this.framesSinceTickLag++,this.doDraw=!0,this.tickQueue-=i;const s=performance.now();if(s-t>33.333333333333336){this.tickQueue=0,this.lastTick=s,this.framesSinceTickLag=0;break}}this.doLerp=this.vsyncRate.shouldLerp()&&this.framesSinceTickLag>=4}updateDraw(){if(!this.doDraw)return;if(!this.canvas||!this.context)throw new Error("Missing canvas");let t;this.doLerp?t=this.tickQueue/i:(t=1,this.doDraw=!1),this.context.clearRect(0,0,this.canvas.width,this.canvas.height),this.currentScene.draw(this,t)}}class n{constructor(){this.tickCount=0}tick(t,i){this.tickCount+=1}draw(t,i,s){const e=64+this.tickCount%60*4,n=64+(this.tickCount-1)%60*4,a=t.drawContextRaw();var c,h,r;a&&(a.fillStyle="rgb(128, 128, 128)",a.fillRect((c=n,h=e,(r=s)<=0?c:r>=1?h:c+r*(h-c)),64,256,256))}}window.onload=function(){const i=new e;i.setScene((()=>{const i=new t,s=new n;return i.addTickLogic(s),i.addDrawLogic(s),i})),i.run()}})();