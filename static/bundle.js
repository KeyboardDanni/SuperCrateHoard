(()=>{"use strict";class t{constructor(t){this.imageElement=new Image,this.imageElement.loading="eager",this.imageElement.src=t}image(){return this.imageElement}waitForLoad(){return t=this,e=void 0,s=function*(){yield this.imageElement.decode()},new((i=void 0)||(i=Promise))((function(n,a){function r(t){try{h(s.next(t))}catch(t){a(t)}}function o(t){try{h(s.throw(t))}catch(t){a(t)}}function h(t){var e;t.done?n(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,o)}h((s=s.apply(t,e||[])).next())}));var t,e,i,s}}class e{constructor(i){if(!e.dataCache[i]){const s=new t(i);e.dataCache[i]=s}this.pictureData=e.dataCache[i]}sharedData(){return this.pictureData}static waitForLoad(){for(const t of Object.values(e.dataCache))t.waitForLoad()}}e.dataCache={};class i{constructor(t){if(this.mainCanvas=document.getElementById(t),!this.mainCanvas||!this.mainCanvas.getContext)throw new Error("Missing canvas");const e=this.mainCanvas.getContext("2d");if(!e)throw new Error("Could not create canvas context");this.drawingContext=e}drawBackgroundColor(t,e,i,s=1){this.drawingContext.fillStyle=`rgb(${t}, ${e}, ${i}, ${s})`,this.drawingContext.fillRect(-1,-1,this.mainCanvas.width+2,this.mainCanvas.height+2)}drawPicture(t,e,i){this.drawingContext.drawImage(t.sharedData().image(),e,i)}drawSprite(t,e,i,s){this.drawingContext.drawImage(t.sharedData().image(),e.x,e.y,e.w,e.h,Math.round(i),Math.round(s),e.w,e.h)}canvas(){return this.mainCanvas}context(){return this.drawingContext}}class s{constructor(){this.bindings=[],this.timeHeld=0}}class n{constructor(){this.heldKeys={},this.actions={},document.addEventListener("keydown",(t=>this.keyDownHandler(t))),document.addEventListener("keyup",(t=>this.keyUpHandler(t)))}keyDownHandler(t){this.heldKeys[t.code]=!0}keyUpHandler(t){this.heldKeys[t.code]=!1}newFrame(){t:for(const t of Object.values(this.actions)){for(const e of t.bindings)if(!0===this.heldKeys[e]){t.timeHeld++;continue t}t.timeHeld=0}}addAction(t,e=[]){if(this.actions[t])throw new Error(`Action "${t}" already exists`);this.actions[t]=new s,this.bindAction(t,e)}bindAction(t,e){const i=this.actions[t];if(!i)throw new Error(`Action "${t}" doesn't exist`);for(const t of e)t in i.bindings||i.bindings.push(t)}clearActionBindings(t){const e=this.actions[t];if(!e)throw new Error(`Action "${t}" doesn't exist`);e.bindings=[]}timeHeld(t){const e=this.actions[t];return e?e.timeHeld:0}held(t){return this.timeHeld(t)>0}justPressed(t){return 1===this.timeHeld(t)}autoRepeat(t,e,i){const s=this.timeHeld(t);return 1===s||s>=e&&(s-e)%i==0}}class a{constructor(){this.tickLogic=[],this.drawLogic=[]}tick(t){for(const e of this.tickLogic)e.tick(t,this)}draw(t,e){for(const i of this.drawLogic)i.draw(t,this,e)}addTickLogic(t){this.tickLogic.push(t)}addDrawLogic(t){this.drawLogic.push(t)}}const r=1e3/60;class o{constructor(){this.timestamp=0,this.goodSamples=0,this.timings=[],this.lastGoodAverage=r}updateTimings(){const t=performance.now();if(this.timestamp<=0)return void(this.timestamp=t);const e=t-this.timestamp;this.timestamp=t,e>20.1||(this.timings.length>=60&&this.timings.shift(),this.timings.length>0&&(Math.abs(this.timings[this.timings.length-1]-e)>6||Math.abs(this.averageRateRaw()-e)>6?this.goodSamples=0:this.goodSamples+=1),this.timings.push(e))}averageRateRaw(){let t=0;for(const e of this.timings)t+=e;return t/this.timings.length}averageRate(){return this.hasEnoughSamples()&&(this.lastGoodAverage=this.averageRateRaw()),this.lastGoodAverage}shouldLerp(){const t=this.averageRate();return Math.abs(t-r)>1}hasEnoughSamples(){return this.goodSamples>60}reset(){this.timestamp=0,this.goodSamples=0,this.timings=[]}}class h{constructor(t){this.currentScene=new a,this.pendingSceneFunc=null,this.vsyncRate=new o,this.lastTick=performance.now(),this.tickQueue=0,this.framesSinceTickLag=0,this.doDraw=!1,this.doLerp=!1,this.running=!1,this.gameInput=new n,this.gameRenderer=new i(t)}run(){if(this.running)throw new Error("run() already called");this.running=!0,this.lastTick=performance.now(),this.tickQueue=0,requestAnimationFrame(this.timerUpdate.bind(this))}scene(){return this.currentScene}setScene(t){this.pendingSceneFunc=t}input(){return this.gameInput}renderer(){return this.gameRenderer}timerUpdate(){this.vsyncRate.updateTimings(),null!==this.pendingSceneFunc&&(this.currentScene=this.pendingSceneFunc(),this.pendingSceneFunc=null),this.updateTicks(),this.updateDraw(),requestAnimationFrame(this.timerUpdate.bind(this))}updateTicks(){const t=performance.now();for(this.tickQueue+=t-this.lastTick,this.lastTick=t;this.tickQueue>=r;){this.gameInput.newFrame(),this.currentScene.tick(this),this.framesSinceTickLag++,this.doDraw=!0,this.tickQueue-=r;const e=performance.now();if(e-t>33.333333333333336){this.tickQueue=0,this.lastTick=e,this.framesSinceTickLag=0;break}}this.doLerp=this.vsyncRate.shouldLerp()&&this.framesSinceTickLag>=4}updateDraw(){if(!this.doDraw)return;let t;this.doLerp?t=this.tickQueue/r:(t=1,this.doDraw=!1),this.gameRenderer.drawBackgroundColor(0,0,0),this.currentScene.draw(this,t)}}const c={x:0,y:96,w:32,h:32};class d{constructor(t){this.crates=[],this.scroll=0,this.scrollSpeed=t,this.image=new e("res/GameAtlas.png");for(let t=0;t<1024;++t)this.crates.push(Math.random()<.3)}tick(t,e){this.scroll+=this.scrollSpeed}draw(t,e,i){const s=t.renderer(),n=Object.assign({},c),[a,r]=[s.canvas().width,s.canvas().height],o=Math.ceil(a/n.w)+1,h=Math.ceil(r/n.h)+1,d=(u=this.scroll-this.scrollSpeed,l=this.scroll,(g=i)<=0?u:g>=1?l:u+g*(l-u));var u,l,g;const m=Math.floor(d/n.w)%32,w=d%n.h;for(let t=0;t<h;++t)for(let e=0;e<o;++e){n.x=(e+t)%2?32:0;const[i,a]=[(e+m)%32,(t+m)%32];this.crates[i+32*a]&&(n.x+=64),s.drawSprite(this.image,n,e*n.w-w,t*n.h-w)}}}window.onload=function(){const t=new h("game_surface"),i=t.input();i.addAction("left",["ArrowLeft","KeyA"]),i.addAction("right",["ArrowRight","KeyD"]),i.addAction("up",["ArrowUp","KeyW"]),i.addAction("down",["ArrowDown","KeyS"]),t.setScene((()=>function(){const t=new a,i=new d(.25);return t.addTickLogic(i),t.addDrawLogic(i),e.waitForLoad(),t}())),t.run()}})();